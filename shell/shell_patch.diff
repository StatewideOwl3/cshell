diff --git a/shell/src/executes.c b/shell/src/executes.c
index 1112141..7269871 100644
--- a/shell/src/executes.c
+++ b/shell/src/executes.c
@@ -1,5 +1,6 @@
 #include "../include/executes.h"
 #include <string.h>
+#include <ctype.h>
  #include <signal.h>
  #include <termios.h>
  #include <errno.h>
@@ -15,12 +16,30 @@ pid_t current_job_pgid = -1;
 struct bg_job* bg_job_head = NULL;
 int next_job_num = 1;
 
+static char* dup_trimmed(const char* src) {
+    if (src == NULL) src = "";
+    while (*src && isspace((unsigned char)*src)) src++;
+    const char* end = src + strlen(src);
+    while (end > src && isspace((unsigned char)*(end - 1))) end--;
+    size_t len = (size_t)(end - src);
+    char* out = malloc(len + 1);
+    if (!out) return NULL;
+    memcpy(out, src, len);
+    out[len] = '\0';
+    return out;
+}
+
 int add_bg_job(pid_t pid, char* cmd_name) {
     struct bg_job* node = malloc(sizeof(struct bg_job));
     if (!node) return -1;
     node->job_num = next_job_num++;
     node->pid = pid;
-    node->cmd_name = strdup(cmd_name ? cmd_name : "(null)");
+    const char* source = (cmd_name && *cmd_name) ? cmd_name : "job";
+    node->cmd_name = dup_trimmed(source);
+    if (!node->cmd_name) {
+        free(node);
+        return -1;
+    }
     node->status = 0;
     node->next = bg_job_head;
     bg_job_head = node;
diff --git a/shell/src/main.c b/shell/src/main.c
index dd5b89d..c4a0ea2 100644
--- a/shell/src/main.c
+++ b/shell/src/main.c
@@ -5,7 +5,9 @@
 #include <string.h>
 
 #include <unistd.h>
+#include <sys/types.h>
 #include <sys/utsname.h>
+#include <pwd.h>
  #include <signal.h>
  #include <termios.h>
  #include <errno.h>
@@ -42,8 +44,12 @@ int main(){
 
     char* username = getlogin();
     if (username == NULL){
-        perror("getlogin() error");
-        exit(1);
+        struct passwd* pw = getpwuid(getuid());
+        if (pw != NULL && pw->pw_name != NULL) {
+            username = pw->pw_name;
+        } else {
+            username = "user";
+        }
     }
 
     // Get the system name from uname struct
diff --git a/shell/src/partB.c b/shell/src/partB.c
index 8bccb2d..9066685 100644
--- a/shell/src/partB.c
+++ b/shell/src/partB.c
@@ -3,6 +3,31 @@
 char* absoluteHomePath = NULL; // Global variable to hold the absolute home path
 
 char* oldWD = NULL;
+char* logFile = NULL;
+
+static const char* getLogFilePath(void) {
+    if (logFile != NULL) return logFile;
+    if (absoluteHomePath == NULL) return NULL;
+
+    size_t len = strlen(absoluteHomePath) + strlen("/logs.txt") + 1;
+    logFile = malloc(len);
+    if (logFile == NULL) return NULL;
+    strcpy(logFile, absoluteHomePath);
+    strcat(logFile, "/logs.txt");
+    return logFile;
+}
+
+static int refresh_directory_state(char** currentWD) {
+    char* updated = getcwd(NULL, 0);
+    if (updated == NULL) {
+        perror("getcwd() error");
+        return -1;
+    }
+    free(oldWD);
+    oldWD = *currentWD;
+    *currentWD = updated;
+    return 0;
+}
 
 static int cmp(const void* a, const void* b) {
     return strcmp(*(char**)a, *(char**)b);
@@ -22,70 +47,66 @@ void executeHop(struct atomic* atomicCmd){
     char** args = terminalCmd->cmdAndArgs;
 
     if (argCount < 2) {
-        // go to home directory
         if (chdir(absoluteHomePath) != 0) {
             perror("hop: chdir to home directory failed");
             free(currentWD);
             return;
         }
+        if (refresh_directory_state(&currentWD) != 0) {
+            free(currentWD);
+            return;
+        }
     }
 
     for (int i = 1; i < argCount; i++) {
+        int changed = 0;
         if (strcmp(args[i], "-") == 0) {
             if (oldWD == NULL) {
-                //perror("hop: OLDPWD not set\n");
-                free(currentWD);
-                return;
+                printf("No such directory!\n");
+                continue;
             }
             if (chdir(oldWD) != 0) {
-                //perror("hop: chdir to OLDPWD failed\n");
-                chdir(currentWD); // revert to current directory
-                free(currentWD);
-                return;
+                printf("No such directory!\n");
+                continue;
             }
-            //printf("%s\n", oldWD);
+            changed = 1;
         } 
         else if (strcmp(args[i], ".")==0){
             // stay in the same directory
             continue;
         }
         else if (strcmp(args[i], "..")==0){
-            // go to parent directory
             if (chdir("..") != 0) {
-                //perror("hop: chdir to parent directory failed\n");
-                chdir(currentWD); // revert to current directory
-                free(currentWD);
-                return;
+                printf("No such directory!\n");
+                continue;
             }
+            changed = 1;
         }
         else if (strcmp(args[i], "~")==0){
-            // go to home directory
             if (chdir(absoluteHomePath) != 0) {
                 perror("hop: chdir to home directory failed");
-                chdir(currentWD); // revert to current directory
                 free(currentWD);
                 return;
             }
+            changed = 1;
         }
         else {
-            // go to specified directory
             if (chdir(args[i]) != 0) {
                 printf("No such directory!\n");
-                chdir(currentWD); // revert to current directory
+                continue;
+            }
+            changed = 1;
+        }
+
+        if (changed) {
+            if (refresh_directory_state(&currentWD) != 0) {
                 free(currentWD);
                 return;
             }
         }
-        // Update oldWD after a successful directory change
-        free(oldWD);
-        oldWD = currentWD;
-        currentWD = getcwd(NULL, 0);
-        if (currentWD == NULL){
-            perror("getcwd() error");
-            return;
-        }
     }
 
+    free(currentWD);
 }
 
 bool checkRevealSyntax(struct atomic* atomicGroup) {
@@ -193,11 +214,9 @@ void executeReveal(struct atomic* atomicGroup){
         //printf("DEBUG: dirPath set to CWD: %s\n", dirPath);  // Add this for debugging
     }
 
-    // If dirPath refers to a regular file (or non-directory), print its name like ls
     struct stat st;
-    if (stat(dirPath, &st) == 0 && !S_ISDIR(st.st_mode)) {
-        if (lineFlag) printf("%s\n", dirPath);
-        else { printf("%s\n", dirPath); } // keep simple one-per-line for file target
+    if (stat(dirPath, &st) != 0 || !S_ISDIR(st.st_mode)) {
+        printf("No such directory!\n");
         if (dirPath_allocated) free(dirPath);
         return;
     }
@@ -205,7 +224,7 @@ void executeReveal(struct atomic* atomicGroup){
     DIR* dir = opendir(dirPath);
     struct dirent* entry;
     if (dir == NULL) {
-        // If cannot open directory and it's not a regular file, just silently return
+        printf("No such directory!\n");
         if (dirPath_allocated) free(dirPath);
         return;
     }
@@ -286,14 +305,14 @@ void executeLog(struct atomic* atomicCmd){
         logListSize = 0;
         saveLog();
     } else if (argCount == 3 && strcmp(args[1], "execute") == 0) {
-        // execute <index>
-        int index = atoi(args[2]);
-        if (index < 1 || index > logListSize) {
-            fprintf(stderr, "log: invalid index\n");
+        char* endptr = NULL;
+        long index = strtol(args[2], &endptr, 10);
+        if (endptr == args[2] || *endptr != '\0' || index < 1 || index > logListSize) {
+            fprintf(stderr, "log: Invalid Syntax!\n");
             return;
         }
         // Find the command: index 1 is newest (tail), index logListSize is oldest (head)
-        int target = logListSize - index + 1; // 1-based from head
+        int target = logListSize - (int)index + 1; // 1-based from head
         struct executedShellCommand* current = listHead;
         for (int i = 1; i < target; i++) {
             current = current->next;
@@ -306,11 +325,10 @@ void executeLog(struct atomic* atomicCmd){
         }
         freeShellCmd(shellCmdStruct);
     } else {
-        printf("log: invalid syntax\n");
+        fprintf(stderr, "log: Invalid Syntax!\n");
     }
 }
 
-char* logFile = "/home/saikapilbharadwaj/Documents/OSN/mini-project-1-StatewideOwl3/shell/logs.txt";
 int logListSize = 0;
 struct executedShellCommand* listHead = NULL;
 struct executedShellCommand* listTail = NULL;
@@ -318,15 +336,11 @@ struct executedShellCommand* listTail = NULL;
 
 // Function to implement persistence feature for storing 15 most recent shell commands across sessions
 void loadLogs(){
-    // Start by constructing path string to files
-    char* path = (char*)malloc(strlen(absoluteHomePath) + strlen("/logs.txt") + 1);
-    strcpy(path, absoluteHomePath);
-    strcat(path, "/logs.txt");
+    const char* path = getLogFilePath();
+    if (path == NULL) return;
 
-    
-    FILE* file = fopen(logFile, "r");
+    FILE* file = fopen(path, "r");
     if (file == NULL) {
-        // If the file doesn't exist, it's not an error; just return
         return;
     }
 
@@ -372,14 +386,11 @@ void loadLogs(){
 }
 
 void saveLog(){
-    char* path = (char*)malloc(strlen(absoluteHomePath) + strlen("/logs.txt") + 1);
-    strcpy(path, absoluteHomePath);
-    strcat(path, "/logs.txt");
-    FILE* file = fopen(logFile, "w+");
-    if (file == NULL) {
-        perror("Failed to open log file for writing");
-        return;
-    }
+    const char* path = getLogFilePath();
+    if (path == NULL) return;
+
+    FILE* file = fopen(path, "w");
+    if (file == NULL) return;
 
     struct executedShellCommand* current = listHead;
     while (current != NULL) {
diff --git a/shell/src/partE.c b/shell/src/partE.c
index c412160..66bd19b 100644
--- a/shell/src/partE.c
+++ b/shell/src/partE.c
@@ -1,6 +1,21 @@
 #include "../include/partE.h"
 #include <sys/wait.h>
 #include <errno.h>
+#include <ctype.h>
+#include <string.h>
+
+static char* dup_trimmed(const char* src) {
+    if (src == NULL) src = "";
+    while (*src && isspace((unsigned char)*src)) src++;
+    const char* end = src + strlen(src);
+    while (end > src && isspace((unsigned char)*(end - 1))) end--;
+    size_t len = (size_t)(end - src);
+    char* out = malloc(len + 1);
+    if (!out) return NULL;
+    memcpy(out, src, len);
+    out[len] = '\0';
+    return out;
+}
 
 struct job* job_list = NULL;
 struct job* jobListTail = NULL;
@@ -11,7 +26,13 @@ void addJob(pid_t pid, char *cmd, int running) {
     //printf("adding job : %d %s %d", pid, cmd, running);
     struct job *new_job = malloc(sizeof(struct job));
     new_job->pid = pid;
-    new_job->command = strdup(cmd);
+    const char* base = cmd ? cmd : "";
+    char* trimmed = dup_trimmed(base);
+    if (!trimmed) {
+        free(new_job);
+        return;
+    }
+    new_job->command = trimmed;
     new_job->running = running;
     new_job->next = job_list;
     job_list = new_job;
